[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15630330&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

## Part 1: Introduction to Software Engineering
### Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is the systematic application of engineering principles, methods and tools in the development and maintenance of high-quality software systems.
Software engineering follows the journey of software applications from the designing, development, testing to the maintenance stage. 
The importance of software engineering in the technology technology lies in how it contribute to technological advancement, how it helps in shaping the digital world and also how it is applicable in organizations for thriving business operations. Different software solutions, that are developed and tailored to align with business objectives and goals, are as a result of software engineering.

Reference:
https://www.institutedata.com/blog/why-is-software-engineering-important/#:~:text=It%20shapes%20our%20digital%20world,needs%20of%20our%20digital%20society.


### Identify and describe at least three key milestones in the evolution of software engineering.
The key milestones in the evolution of software engineering follows the pathway described below.
- Mastering the Machine: This era between 1956 and 1967 saw software that are essentially developed to exploit the limited hardware resources. Even the word "software engineering" has not be introduced yet and sofware development methods are lacking.
- Mastering the Process: This was the era between 1968 and 1982 which brought about the inception of software development methods. Structured software development methods such as Software Requirement Engineering Methodology (SREM) and Structured Analysis and Design Techniques (SADT) were introduced. This evolution were essentially the resultant of software crisis and the software engineering was birthed.
- Mastering the Complexity: In between 1983 and 1992, the dominance of hardware over software ended. This gave room to personal computers and consquently the feilds of computer applications were brought to life. From that era, the processes in software developmnent follows analysis and design from specifications critically.
- Mastering the Communications: Software engineering bends towards broader software concepts when the internet emerge. This era between 1993 and 2001 saw decentralization of functions and data, and this brought about accelerated development and expansion of various areas of computing including the distributed architecture, concurrent programming and web engineering as a new software engineering discipline.
- Mastering the Productivity: The trend during this period between 2002 and 2010 was development of software systems known as the information management systems. These software systems were focused on improving business management and this sped up introduction and adoption of different software engineering methodologies. The agile methodologies emerged during this era which is a crucial milestone in the evolution of software engineering in that period.
- Mastering the Market: This is the period we are currently in since 2011 and there are now various platforms for integration and interoperability between different information systems. Cloud computing emerged and businesses now are familiarized with products being sold as a service. Also, customers now have mobile applications on their devices (smartphones, tablets, laptops) and the demands are ever increasing.

Reference:
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3927817/


### List and briefly explain the phases of the Software Development Life Cycle.
- Development Life Cycle (SDLC) follows through the phase of gathering requirements, design, implementation, testing, deployment to the maintenance phase.
- Requirement: This phase of the SDLC involves gathering of requirements for the software projects. These requirements include user needs, system requirements, etc
- Design: This phase is the prototyping stage. It involves the creation of detailed designs for software architecture, user interface. It usually includes the wireframes of the software applications.
- Implementation: This is the phase where the actual development of the software applications takes place. It involves writing codes and building the project based on design specifications.
- Testing: This phase involves testing the software to ascertain that it meets quality standard and functional requirements.
- Deployment: This phase involves making the software applications ready to customers (or users) for use.
- Maintenance: This phase involves continuous improvement of the software application through support and updates (enhancement or addition of features, fixing bugs, etc.) 


### Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
Agile model of software development follows an iterative and incremental approaches to software development, while waterfall model of software development 
follows a linear, sequential approach to software development through the SDLC. 
The key difference between agile and waterfall models are their approach to software development, predictability, adaptability to changes (project needs, scope creep) and team dynamics where agile model is flexible, waterfall model is rigid and where agile model fosters collaboration, waterfall model has some shortcomings.
Agile model might be preferred in fast-paced production environment with changing project and usersâ€™ needs (such as shopping platform dev.). And, the waterfall model might be preferred in scenarios with fixed project outline from start to finish.


### Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
- Software Developer: 
Sofware developer is responsible for designing, programming, building, deployment and maintenance of software using many different skills and tools. A software developer also help in building software systems that power networks and devices and ensure that the systems are functional. 
- Quality Assurance Engineer: 
Quality assurance engineers are responsible for ensuring that a software passes all checks before it is released to the public. They also oversee every phase of design, development, testing and delivery to ensure that the product meets the quality standards and requirements. Their responsibilities also include reporting to the project manager on product status.
- Project manager: 
The project manager is responsible for overseeing the planning, execution and delivery of software projects. Basically, a project manager leads a development team in achieving all project goals within the specified time constraints. 
Some of the responsibilities of managing software projects as a project manager are project monitoring and control, timely delivery of software projects, cost control, resource and risk management, quality assurance and ensuring stakeholder satisfaction.


### Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
- Integrated Development Environments (IDEs):
IDEs are the software applications that provision comprehensive facilities for software development. At the basic level, an IDE consists of the source-code editor, build automation tools and debugger. Visual Studio Code, Atom, Eclipse, NetBeans and PyCharm are examples of IDEs.
- Version control systems: 
Version control systems are software tools that track changes made to source codes. Version control systems are important in software development as they not only source codes changes but facilitate work coordination amongst development team members. Git and subversion are examples of version control system. These examples of version control control systems are have unique features. For instance, the Git is a distributed version control system with fast commit speeds. Git also support offline work mode. Git is flexible and advanced, however, with steeper learning curve. Apache subversion (commonly known as subversion) is a centralized version control system with files and data stored on central servers. It is beginner-friendly in terms of ease of use but with limited offline work mode. 

References
https://nulab.com/learn/software-development/git-vs-svn-version-control-system/

### What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
Some of the challenges that software engineers faces include tight deadlines, changing requirements of the software projects, technical debt and so on. Technical debt is simply the results of when development teams take actions to expedite the delivery of a piece of functionality or a project which later needs to be refactored (a project rework). In other words, it's the result of prioritizing speedy delivery over perfect code.
Other common challenges include lack of workflows visibility, resource allocation, project delay due to resource unavailability, lack of accountability (in team members), team communication issues, and many among others.
Strategies to overcome these challenges include:
- Effective project planning
- Effective communication and collaboration
- Regular review and update of the project documentation
- Embracing agile methodologies
- Investment in continuous learning

References:
https://www.productplan.com/glossary/technical-debt

https://www.koombea.com/blog/project-manager-challenges/

https://www.metridev.com/metrics/software-engineering-challenges-overcoming-obstacles/

https://onecodecamp.com/blogdetail/Engineering_Resilience:_Overcoming_Challenges_in_Software_Development


### Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
The different types of software testing are as follows:
- Unit testing: This type of testing involves the testing of individual component and module of the software.
- Integration testing: This involves testing the interaction between different components or subsystem of the software.
- System testing: This involves the overall testing of the entire system as a whole.
- Acceptance testing: This type of testing deals with testing the software against user requirements to ensure that the acceptance criteria based on usersâ€™ needs are ticked off.
 
Testing is essential in software quality assurance as this phase helps in ensuring that the software meets quality standards and functional requirements.


## Part 2: Introduction to AI and Prompt Engineering
### Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the art of crafting clear instructions to AI systems in order to generate context-appropriate contents that meets the tasks specific needs. Prompt engineering follows the these for principles: Single, Specific, Short and Surround.
Prompt engineering is important in the interaction with AI models as it allows the model to give comprehensive and adequate response to a prompt and also learn from the prompts to deliver better responses.

### Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
- Vague prompt: Tell a story of a young girl to me
- Improved Prompt: Assumming the persona of children-stories teller, tell a sweet short story of a young bright girl who have deep interests in science and arts and live in Lagos state, Nigeria.
  
The improved prompt is more effective as it is clear, specific and concise and this provides the AI model with clear instructions and more information to deliver an adequate and context-appropriate response.
